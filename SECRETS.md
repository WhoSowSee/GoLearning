# Go by Example

## Переменные

```go
var a = "initial"
fmt.Println(a) // initial

var b, c int = 1, 2
fmt.Println(b, c) // 1 2

var d = true
fmt.Println(d) // true

var e int
fmt.Println(e) // 0

f := "apple"
fmt.Println(f) // apple
```

## Константы

В Go константы могут принимать значения следующих типов: строки, числа и логические значения
Оператор const может использоваться везде, где может быть использован оператор var
Числовая константа не имеет типа до тех пор, пока ей не присвоен, например, при явном преобразовании

## Цикл for

for <инициализация>; <условие>; <выражение после for> {тело}

Классическая инициализация/условие/выражение после for:

for j := 7; j <= 9; j++ {
fmt.Println(j)
}

Чтобы пропустить итерацию, можно использовать оператор `continue`
Если цикл вложенный, можно использовать `метку`, чтобы пропускать внешний цикл
То же самое касается и оператора break

```go
Label1: // Метка может быть с любым названием
    for i := 1; i <= 20; i++ {
        for j := 1; j <= 10; j++ {
            fmt.Println("I:", i, "J:", j)
            if i >= 10 {
                continue Label1
            }
        }
    }
```

## Switch

```go
i := 2

switch i {
case 1:
fmt.Println("one")
case 2:
fmt.Println("two")
case 3:
fmt.Println("three")
}

```

Вы можете использовать запятую в качестве разделителя, для перечисления нескольких значений в case. Так же в данном
примере используется блок по-умолчанию default

```go
switch time.Now().Weekday() {
case time.Saturday, time.Sunday:
fmt.Println("It's the weekend")
default:
fmt.Println("It's a weekday")
}
```

switch без условия аналогичен обычному оператору if/else по своей логике. Так же в этом примере что в case можно
использовать не только константы

```go
t := time.Now()
switch {
case t.Hour() < 12:
fmt.Println("It's before noon")
default:
fmt.Println("It's after noon")
}
```

В этой конструкции switch сравниваются типы значений. Вы можете использовать этот прием, для определения типа значения
интерфейса

```go
whatAmI := func (i interface{}) {
switch t := i.(type) {
case bool:
fmt.Println("I'm a bool")
case int:
fmt.Println("I'm an int")
default:
fmt.Printf("Don't know type %T\n", t)
}
```

## Массивы

Массив - статическая переменная

```go
// arr := [размер массива]<тип данных>{элементы}
arr := [5]int{56, 64, 35, 11, 41}
```

Чтобы вручную не писать длину массива, можно попросить компилятор подсчитать элементы массива за вас:

```go
arr := [...]string{"Penn", "Teller"}
```

### Слайсы

Слайсы - динамический массив
Вместимость - сколько элементов может поместиться в `слайс`
Длина - фактическое число элементов, лежащих в `слайс`

Чтобы посмотреть значения вместимости и длины воспользуемся функциями `len` и `cap`

```go
arr := []int{56, 64, 35, 11, 41}
fmt.Println( "Длина =", len(arr), "Вместимость =", cap(arr))
```

```go
arr := []int{56, 64, 35, 11, 41}
```

Чтобы добавить элемент в конец `слайса`, можно воспользоваться функцией `append`

```go
arr := []int{56, 64, 35, 11, 41}
arr = append(arr, 33)
```

При добавлении элемента в `слайс`, его вместимость увеличивается дважды от текущей вместимости, если длина `слайса`
после `append` превышает текущую вместимость

Мы можем создать `слайс` с определенной вместимостью

```go
arr2 := make([]int, 0, 500) // 0 - длина, 500 - вместимость
```
