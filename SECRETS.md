## Переменные

```go
var a = "initial"
fmt.Println(a) // initial

var b, c int = 1, 2
fmt.Println(b, c) // 1 2

var d = true
fmt.Println(d) // true

var e int
fmt.Println(e) // 0

f := "apple"
fmt.Println(f) // apple
```

## Константы

> В Go константы могут принимать значения следующих типов: строки, числа и логические значения

> Оператор const может использоваться везде, где может быть использован оператор var

> Числовая константа не имеет типа до тех пор, пока ей не присвоен, например, при явном преобразовании

## Цикл for

for <инициализация>; <условие>; <выражение после for> {тело}

Классическая инициализация/условие/выражение после for:

for j := 7; j <= 9; j++ {
fmt.Println(j)
}

Чтобы пропустить итерацию, можно использовать оператор `continue`
Если цикл вложенный, можно использовать `метку`, чтобы пропускать внешний цикл
То же самое касается и оператора break

```go
Label1: // Метка может быть с любым названием
    for i := 1; i <= 20; i++ {
        for j := 1; j <= 10; j++ {
            fmt.Println("I:", i, "J:", j)
            if i >= 10 {
                continue Label1
            }
        }
    }
```

## Switch

```go
i := 2

switch i {
case 1:
    fmt.Println("one")
case 2:
    fmt.Println("two")
case 3:
    fmt.Println("three")
}
```

Вы можете инициализировать переменную сразу в `switch`, но это будет локальной переменной, и ее область видимости ограничивается данным `switch/case`:

```go
switch i := 2; i {
case 1:
    fmt.Println("one")
case 2:
    fmt.Println("two")
case 3:
    fmt.Println("three")
}
```

Вы можете использовать запятую в качестве разделителя, для перечисления нескольких значений в case. Так же в данном
примере используется блок по-умолчанию `default`

```go
switch time.Now().Weekday() {
case time.Saturday, time.Sunday:
    fmt.Println("It's the weekend")
default:
    fmt.Println("It's a weekday")
}
```

Вы можете использовать оператор `fallthrough`, который позволит, в случае если один из `case` сработал, прейти также и к следующему `case`:

```go
switch num := rand.Intn(5-1) + 1; num {
case 1:
    fmt.Println("Number is one")
case 2, 3:
    fmt.Println("Number is two or three")
case getFour():
    fmt.Println("Number is four")
    fallthrough
case 10:
    fmt.Println("Strange things happens")
default:
    fmt.Println("Default case is shown")
}
```

> switch без условия аналогичен обычному оператору if/else по своей логике. Так же в этом примере, что в case можно спользовать не только константы

```go
t := time.Now()
switch {
case t.Hour() < 12:
    fmt.Println("It's before noon")
default:
    fmt.Println("It's after noon")
}
```

В этой конструкции switch сравниваются типы значений. Вы можете использовать этот прием, для определения типа значения
интерфейса

```go
whatAmI := func (i interface{}) {
switch t := i.(type) {
case bool:
    fmt.Println("I'm a bool")
case int:
    fmt.Println("I'm an int")
default:
    fmt.Printf("Don't know type %T\n", t)
}
}
```

## Массивы

Массив - статическая переменная

```go
// arr := [размер массива]<тип данных>{элементы}
arr := [5]int{56, 64, 35, 11, 41}
```

Чтобы вручную не писать длину массива, можно попросить компилятор подсчитать элементы массива за вас:

```go
arr := [...]string{"Penn", "Teller"}
```

### Слайсы

> **Слайсы** - динамический массив

> **Вместимость** - сколько элементов может поместиться в `slice`

> **Длина** - фактическое число элементов, лежащих в `slice`

Чтобы посмотреть значения вместимости и длины воспользуемся функциями `len` и `cap`

```go
arr := []int{56, 64, 35, 11, 41}
fmt.Println( "Длина =", len(arr), "Вместимость =", cap(arr))
```

```go
arr := []int{56, 64, 35, 11, 41}
```

Чтобы добавить элемент в конец `слайса`, можно воспользоваться функцией `append`

```go
arr := []int{56, 64, 35, 11, 41}
arr = append(arr, 33)
```

При добавлении элемента в `слайс`, его вместимость увеличивается дважды от текущей вместимости, если длина `слайса`
после `append` превышает текущую вместимость

Мы можем создать `слайс` с определенной вместимостью

```go
arr2 := make([]int, 0, 500) // 0 - длина, 500 - вместимость
```

## Пакеты

Чтобы скачать сторонний пакет (github), нужно воспользоваться утилитой go - `go get`
Сторонние пакеты устанавливаются по пути GOPATH/src

```shell
go get <путь к пакету>

go get "golang.org/x/sync/errgroup"
```

## Модули

Чтобы создать модуль, нужно воспользоваться утилитой `go mod init`

```shell
go mod init <имя модуля>
```

Чтобы добавить в файл `go.mod` текущие зависимости нужно воспользоваться утилитой `go mod tidy`

## Указатели

**В _Go_ при вызове функции, создается копия каждого аргумента функции, независимо от их размера -> медленная работа программы, чтобы это исправить, можно использовать указатели**

**Указатели** - это тип данных, которые в качестве значения хранят адрес ячейки памяти значения, либо другого указателя (может быть nil)

> Так как, значение указателя может быть `nil`, то перед тем как разыменовать указатель, стоит выполнить проверку на `nil`\
> Проблемы можно избежать, создавая указатель не через \*, а через функцию `new`. Данная функция создает указатель, но по умолчанию значение не `nil`, а значения типа перменной _(int, int32, float64)_

```go
// Данный способ лишь объявляет указатель `valuePtr` на тип `int64`, но не присваиваеm ему никакого значения. Поэтому вывод будет `nil`
var valuePtr *int64
fmt.Println(valuePtr2) // <nil>

// Данный способ выделяет память для указанного типа и возвращает указатель на эту область памяти, при этом память инициализируется значением по умолчанию для типа `int64`, то есть `0`. Поэтому мы видим адрес на ячейку памяти
var valuePtr2 = new(int64)
fmt.Println(valuePtr) // 0xc00000a0e8
```

> Поэтому же, в данном случае для `var ptr *T` возникнет `panic`, а для `new(T)` все будет работать корректно

```go
// Так как `nil` не указывает на действительное место в памяти, это приводит к panic
var valuePtr *int64
fmt.Println(*valuePtr2) // panic: runtime error: invalid memory address or nil pointer dereference

// Так как память была выделена и инициализирована значением по умолчанию для int64, результатом будет 0.
var valuePtr2 = new(int64)
fmt.Println(*valuePtr) // 0


```

> Указатели - это переменные, которые указывают на определенную область памяти

> Значение самой переменной представляет собой адрес памяти

Для доступа к данным необходимо выполнить разыменование указателя (\*)\
Это позволяет изменять значения, которые существуют в других частях программы\

### Создание указателей

> Оператор разыменования или астериск (\*) вместе с типом указывает, что значение является указателем

> Амперсанд (&) создает указатель на переменную

```go
value := 10 value := 10 valuePtr := &value
var valuePtr *int
valuePtr = &value
```

### Использование указателей

> Астериск (\*) при использовании с указателем будет разыменовывать указатель

> Это предоставляет доступ к фактическим данным, на которые указывает указатель

```go
func increment(x *int) {
    *х++
}
i := 1
increment (&i)
// i == 2 => Взаимодействие с указателями меняет изначальное значение переменной
```

### Вывод

| Указатели используются для изменения данных, существующих вне функции\
| Астериск (\*) перед типом указывает, что тип является указателем\
| Амперсанд (&) создает указатель\
| Астериск (\*) перед переменной разыменовывает указатель\
| Операции с разыменованным указателем выполняются над исходными данными

**Разница между `new` и `var` для указателей:**

- **`new(T)`**:

  - Выделяет область памяти, достаточную для хранения значения типа `T`.
  - Инициализирует эту область памяти **нулевым значением** для типа `T` (для чисел это 0, для строк - пустая строка, для указателей - `nil`).
  - Возвращает **указатель** на выделенную область памяти.

- **`var ptr *T`**:
  - Объявляет переменную `ptr` как **указатель** на тип `T`.
  - **Не выделяет память!** Указатель `ptr` будет иметь нулевое значение, которое для указателей обозначается как `nil`.
